<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>three-text WebGL Example</title>
  <style>
    body { 
      margin: 0; 
      background: #000;
      color: #fff;
      font-family: sans-serif;
    }
    canvas { 
      display: block; 
      width: 100%;
      height: 100vh;
    }
    #status {
      position: fixed;
      bottom: 50px;
      left: 20px;
      padding: 10px 15px;
      background: rgba(0, 0, 0, 0.8);
      border-radius: 4px;
      font-size: 12px;
      z-index: 100;
      backdrop-filter: blur(10px);
    }
    .status-loading { color: #ffa500; }
    .status-ready { color: #00ff00; }
    .status-error { color: #ff4444; }
  </style>
</head>
<body>
  <div id="status" class="status-loading">Initializing WebGL...</div>
  <canvas id="canvas"></canvas>

  <script type="module">
    import { Text } from '../dist/index.js';
    import { createWebGLBuffers } from '../dist/webgl/index.js';

    const status = document.getElementById('status');

    async function main() {
      const canvas = document.getElementById('canvas');
      const gl = canvas.getContext('webgl2', { antialias: true }) || canvas.getContext('webgl', { antialias: true });
      
      if (!gl) {
        status.textContent = 'WebGL not supported';
        status.className = 'status-error';
        return;
      }
      
      const devicePixelRatio = window.devicePixelRatio || 1;
      canvas.width = canvas.clientWidth * devicePixelRatio;
      canvas.height = canvas.clientHeight * devicePixelRatio;

      gl.viewport(0, 0, canvas.width, canvas.height);
      gl.clearColor(0.05, 0.05, 0.05, 1.0);
      gl.enable(gl.DEPTH_TEST);
      gl.disable(gl.CULL_FACE);

      status.textContent = 'Loading font and generating text...';

      // Initialize three-text
      Text.setHarfBuzzPath('/examples/hb/hb.wasm');

      const textGeometry = await Text.create({
        text: 'Hello WebGL!',
        font: './fonts/NimbusSanL-Reg.woff',
        size: 72,
        depth: 30
      });

      status.textContent = 'Creating WebGL buffers...';

      // Create WebGL buffers from geometry
      const bufferSet = createWebGLBuffers(gl, textGeometry);

      const bounds = textGeometry.planeBounds;
      const centerX = (bounds.min.x + bounds.max.x) / 2;
      const centerY = (bounds.min.y + bounds.max.y) / 2;
      const width = bounds.max.x - bounds.min.x;
      const height = bounds.max.y - bounds.min.y;
      
      status.textContent = `Ready: ${bufferSet.drawCount / 3} triangles`;
      status.className = 'status-ready';
      
      // WebGL Shaders
      const vertexShaderSource = `
        attribute vec3 position;
        attribute vec3 normal;
        
        uniform mat4 uMVP;
        
        varying vec3 vNormal;
        
        void main() {
          vNormal = normal;
          gl_Position = uMVP * vec4(position, 1.0);
        }
      `;

      const fragmentShaderSource = `
        precision mediump float;
        
        varying vec3 vNormal;
        
        void main() {
          // Light from behind-top-left
          vec3 lightDir = normalize(vec3(-0.5, 0.5, -1.0));
          vec3 normal = normalize(vNormal);
          
          float diffuse = max(dot(normal, lightDir), 0.0);
          float ambient = 0.6;
          float lighting = ambient + diffuse * 0.8;
          
          gl_FragColor = vec4(vec3(1.0) * lighting, 1.0);
        }
      `;

      // Compile shaders
      const vertexShader = gl.createShader(gl.VERTEX_SHADER);
      gl.shaderSource(vertexShader, vertexShaderSource);
      gl.compileShader(vertexShader);
      if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {
        console.error('Vertex shader error:', gl.getShaderInfoLog(vertexShader));
      }

      const fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);
      gl.shaderSource(fragmentShader, fragmentShaderSource);
      gl.compileShader(fragmentShader);
      if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {
        console.error('Fragment shader error:', gl.getShaderInfoLog(fragmentShader));
      }

      // Create program
      const program = gl.createProgram();
      gl.attachShader(program, vertexShader);
      gl.attachShader(program, fragmentShader);
      gl.linkProgram(program);
      if (!gl.getProgramParameter(program, gl.LINK_STATUS)) {
        console.error('Program link error:', gl.getProgramInfoLog(program));
      }
      gl.useProgram(program);

      // Get attribute and uniform locations
      const positionLoc = gl.getAttribLocation(program, 'position');
      const normalLoc = gl.getAttribLocation(program, 'normal');
      const mvpLoc = gl.getUniformLocation(program, 'uMVP');

      // Setup VAO (WebGL2) or manual attribute binding (WebGL1)
      let vao = null;
      if (gl.createVertexArray) {
        vao = gl.createVertexArray();
        gl.bindVertexArray(vao);
      }

      // Bind position buffer
      gl.bindBuffer(gl.ARRAY_BUFFER, bufferSet.buffers.position);
      gl.vertexAttribPointer(positionLoc, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(positionLoc);

      // Bind normal buffer
      gl.bindBuffer(gl.ARRAY_BUFFER, bufferSet.buffers.normal);
      gl.vertexAttribPointer(normalLoc, 3, gl.FLOAT, false, 0, 0);
      gl.enableVertexAttribArray(normalLoc);

      // Bind index buffer
      gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, bufferSet.buffers.indices);

      if (vao) {
        gl.bindVertexArray(null);
      }

      // Static angle to show 3D depth
      const staticYaw = 0.4;
      const staticPitch = 0.2;

      // Camera matrices
      function getMatrices() {
        const aspect = canvas.width / canvas.height;
        
        // Fit text in viewport
        const padding = 1.8;
        const scaleX = 2 / (width * padding);
        const scaleY = (2 / (width * padding)) * aspect;
        const translateX = -centerX * scaleX;
        const translateY = -centerY * scaleY;
        
        // Static rotation
        const cy = Math.cos(staticYaw);
        const sy = Math.sin(staticYaw);
        const cp = Math.cos(staticPitch);
        const sp = Math.sin(staticPitch);
        
        // MVP
        return new Float32Array([
          scaleX * cy, scaleX * sy * sp, scaleX * sy * cp, 0,
          scaleY * 0, scaleY * cp, scaleY * -sp, 0,
          0.001 * -sy, 0.001 * cy * sp, 0.001 * cy * cp, 0,
          translateX, translateY, 0, 1
        ]);
      }

      // Render loop
      function render() {
        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);

        const mvp = getMatrices();
        gl.uniformMatrix4fv(mvpLoc, false, mvp);

        if (vao) {
          gl.bindVertexArray(vao);
        }

        gl.drawElements(gl.TRIANGLES, bufferSet.drawCount, gl.UNSIGNED_INT, 0);

        if (vao) {
          gl.bindVertexArray(null);
        }

        requestAnimationFrame(render);
      }

      render();

      // Handle resize
      window.addEventListener('resize', () => {
        canvas.width = canvas.clientWidth * devicePixelRatio;
        canvas.height = canvas.clientHeight * devicePixelRatio;
        gl.viewport(0, 0, canvas.width, canvas.height);
      });
    }

    main().catch(err => {
      console.error(err);
      status.textContent = `Error: ${err.message}`;
      status.className = 'status-error';
    });
  </script>
</body>
</html>
