<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>three-text interactive demo</title>
    <style>
      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: sans-serif;
        background: #0a0a0a;
        color: #f3f3f3;
        overflow: hidden;
      }

      #container {
        position: fixed;
        top: 0;
        left: 0;
        width: 100%;
        height: 100%;
      }

      canvas {
        display: block;
        cursor: grab;
      }

      canvas:active {
        cursor: grabbing;
      }

      #gui {
        position: fixed;
        top: 20px;
        right: 20px;
        background: rgba(0, 0, 0, 0.8);
        border: 1px solid #333;
        border-radius: 8px;
        padding: 20px;
        min-width: 280px;
        z-index: 100;
        backdrop-filter: blur(10px);
      }

      .control-group {
        margin-bottom: 20px;
      }

      .control-group:last-child {
        margin-bottom: 0;
      }

      label {
        display: block;
        margin-bottom: 8px;
        font-size: 14px;
        font-weight: 500;
        color: #ccc;
      }

      input[type="range"] {
        width: 100%;
        height: 6px;
        border-radius: 3px;
        background: #333;
        outline: none;
        margin-bottom: 8px;
        appearance: none;
        -webkit-appearance: none;
      }

      input[type="range"]::-webkit-slider-thumb {
        -webkit-appearance: none;
        appearance: none;
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0066cc;
        cursor: pointer;
        border: 2px solid #fff;
      }

      input[type="range"]::-moz-range-thumb {
        width: 18px;
        height: 18px;
        border-radius: 50%;
        background: #0066cc;
        cursor: pointer;
        border: 2px solid #fff;
      }

      .value-display {
        font-size: 12px;
        color: #888;
        text-align: right;
      }

      select,
      textarea {
        width: 100%;
        padding: 8px;
        background: #222;
        border: 1px solid #444;
        border-radius: 4px;
        color: #fff;
        font-size: 14px;
      }

      textarea {
        resize: vertical;
        min-height: 80px;
      }

      button {
        width: 100%;
        padding: 10px;
        background: #0066cc;
        border: none;
        border-radius: 4px;
        color: white;
        font-size: 14px;
        font-weight: 500;
        cursor: pointer;
        transition: background-color 0.2s;
      }

      button:hover {
        background: #0088ff;
      }

      button:active {
        background: #004499;
      }

      #status {
        position: fixed;
        bottom: 50px;
        left: 20px;
        padding: 10px 15px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 4px;
        font-size: 12px;
        z-index: 100;
        backdrop-filter: blur(10px);
      }

      .status-loading {
        color: #ffa500;
      }
      .status-ready {
        color: #00ff00;
      }
      .status-error {
        color: #ff4444;
      }

      #branding {
        position: fixed;
        bottom: 20px;
        left: 20px;
        padding: 8px 12px;
        background: rgba(0, 0, 0, 0.8);
        border-radius: 4px;
        font-size: 11px;
        z-index: 100;
        backdrop-filter: blur(10px);
        display: flex;
        align-items: center;
        gap: 8px;
        color: #888;
        text-decoration: none;
      }

      #branding svg {
        width: 16px;
        height: 16px;
        fill: currentColor;
      }

      @media (max-width: 768px) {
        #gui {
          top: 10px;
          right: 10px;
          left: 10px;
          min-width: auto;
          padding: 15px;
        }

        #status {
          bottom: 50px;
          left: 10px;
          right: 10px;
          text-align: center;
        }

        #branding {
          bottom: 10px;
          left: 10px;
          right: 10px;
          justify-content: center;
        }
      }

      @media (max-height: 600px) {
        #gui {
          max-height: calc(100vh - 40px);
          overflow-y: auto;
        }
      }
    </style>
  </head>
  <body>
    <div id="container"></div>

    <div id="status" class="status-loading">Initializing...</div>

    <a id="branding" href="https://github.com/countertype/three-text" target="_blank">
      <span>three-text</span>
      <svg viewBox="0 0 16 16" xmlns="http://www.w3.org/2000/svg">
        <path d="M8 0C3.58 0 0 3.58 0 8c0 3.54 2.29 6.53 5.47 7.59.4.07.55-.17.55-.38 0-.19-.01-.82-.01-1.49-2.01.37-2.53-.49-2.69-.94-.09-.23-.48-.94-.82-1.13-.28-.15-.68-.52-.01-.53.63-.01 1.08.58 1.23.82.72 1.21 1.87.87 2.33.66.07-.52.28-.87.51-1.07-1.78-.2-3.64-.89-3.64-3.95 0-.87.31-1.59.82-2.15-.08-.2-.36-1.02.08-2.12 0 0 .67-.21 2.2.82.64-.18 1.32-.27 2-.27.68 0 1.36.09 2 .27 1.53-1.04 2.2-.82 2.2-.82.44 1.1.16 1.92.08 2.12.51.56.82 1.27.82 2.15 0 3.07-1.87 3.75-3.65 3.95.29.25.54.73.54 1.48 0 1.07-.01 1.93-.01 2.2 0 .21.15.46.55.38A8.013 8.013 0 0016 8c0-4.42-3.58-8-8-8z"/>
      </svg>
    </a>
    <script type="importmap">
      {
        "imports": {
          "three": "../node_modules/three/build/three.module.js",
          "three/addons/": "../node_modules/three/examples/jsm/",
          "three-text": "../dist/index.js",
          "three-text/three": "../dist/three/index.js"
        }
      }
    </script>
    
    <script type="module">
      import * as THREE from "three";
      import { OrbitControls } from "three/addons/controls/OrbitControls.js";
      import { GUI } from "three/addons/libs/lil-gui.module.min.js";
      import { Text } from "three-text/three";

      Text.setHarfBuzzPath("/examples/hb/hb.wasm");

      (async () => {
        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x111111);

        const availableLanguages = [
          "en-us", "en-gb", "de-1996", "fr", "es", "it", "pt", "nl", "da", "sv",
          "nb", "nn", "fi", "is", "pl", "cs", "sk", "sl", "hr", "sr-cyrl",
          "sh-cyrl", "sh-latn", "ru", "uk", "be", "bg", "mk", "el-monoton",
          "el-polyton", "hy", "ka", "tr", "tk", "sq", "et", "lv", "lt", "ro",
          "hu", "ca", "oc", "gl", "eu", "cy", "ga", "eo", "ia", "la", "af",
          "id", "hi", "bn", "as", "gu", "pa", "or", "ml", "kn", "ta", "te",
          "mr", "sa", "th", "kmr", "hsb", "fur", "rm", "pms", "zh-latn-pinyin",
          "mn-cyrl", "mul-ethi"
        ];

        function updateStatus(message, type = "loading") {
          const status = document.getElementById("status");
          status.textContent = message;
          status.className = `status-${type}`;
        }

        let camera, renderer, controls, textMesh;
        let isRendering = false;
                let time = 0;
        let gui;
        let textFolder;
        let customFontBuffer = null;
        let currentFontName = "NimbusSanL-Reg.woff";
        let variableFontControllers = [];
        let currentShaderMode = 'wave';
        let shaderFolders = {};

        const params = {
          text: "three-text renders and formats text from TTF, OTF, and WOFF font files in Three.js. It uses TeX-based parameters for breaking text into paragraphs across multiple lines, and turns font outlines into 3D shapes on the fly, caching their geometries for low CPU overhead in languages with lots of repeating glyphs. Variable fonts are supported as static instances at a given axis coordinate. Under the hood, three-text relies on HarfBuzz for text shaping, Knuth-Plass line breaking, Liang hyphenation, libtess2 (based on the GLU tessellator by Eric Veach) for removing overlaps and triangulation, bezier curve polygonization from Maxim Shemanarev's Anti-Grain Geometry, Visvalingam-Whyatt line simplification, and Three.js as a platform for 3D rendering on the web",
          lineWidth: 1400,
          fontSize: 72,
          lineHeight: 1.33,
          letterSpacing: 0,
          direction: "ltr",
          depth: 7,
          alignment: "justify",
          optimizationEnabled: true,
          areaThreshold: 1.0,
          colinearThreshold: 0.0087,
          minSegmentLength: 0.25,
          removeOverlaps: null,

          waveSpeed: 1.0,
          waveHeight: 10,
          waveFrequency: 0.01,

          shaderMode: 'wave',

          flipSpeed: 0.3,
          flipPauseDuration: 0.3,

          explodeSpeed: 0.4,
          explodeDistance: 1800,

          orbitRadius: 30,
          orbitSpeed: 0.5,

          twisterSpeed: 0.5,
          twisterHeight: 150,
          twisterRadius: 300,

          hyphenate: true,
          language: "en-us",
          lefthyphenmin: 2,
          righthyphenmin: 4,
          hyphenpenalty: 50,
          exhyphenpenalty: 50,
          doublehyphendemerits: 10000,

          tolerance: 200,
          pretolerance: 100,
          emergencyStretch: 0,
          looseness: 0,
          linepenalty: 10,
          adjdemerits: 10000,
          respectExistingBreaks: true,
          disableSingleWordDetection: false,
          distanceTolerance: 0.5,
          angleTolerance: 0.25,
        };

        const waveVertexShader = `
            uniform float time;
            uniform float waveHeight;
            uniform float waveFrequency;
            varying vec3 vColor;
            varying vec3 vNormal;
            varying float vIsBackFace;

            void main() {
                vec3 pos = position;
                
                float wave = sin(position.x * waveFrequency + time) * 
                            sin(position.y * waveFrequency + time);
                
                pos.x += wave * waveHeight * 0.25;
                pos.y += wave * waveHeight * 0.25;
                pos.z += wave * waveHeight;
                
                vec3 newNormal = normal;
                float waveGradientX = cos(position.x * waveFrequency + time) * waveFrequency * waveHeight * 0.25;
                float waveGradientY = cos(position.y * waveFrequency + time) * waveFrequency * waveHeight * 0.25;
                newNormal.x -= waveGradientX;
                newNormal.y -= waveGradientY;
                newNormal = normalize(newNormal);
                
                vec4 worldNormal = modelMatrix * vec4(newNormal, 0.0);
                vec4 worldPosition = modelMatrix * vec4(pos, 1.0);
                vec3 viewDirection = normalize(cameraPosition - worldPosition.xyz);
                float facing = dot(worldNormal.xyz, viewDirection);
                
                if (facing < 0.0) {
                    newNormal = -newNormal;
                    vIsBackFace = 1.0;
                } else {
                    vIsBackFace = 0.0;
                }
                
                vColor = color;
                vNormal = normalize(normalMatrix * newNormal);
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const waveFragmentShader = `
            uniform float opacity;
            varying vec3 vColor;
            varying vec3 vNormal;
            varying float vIsBackFace;
            
            void main() {
                vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));
                vec3 normal = normalize(vNormal);
                
                float diffuse = max(dot(normal, lightDirection), 0.0);
                float ambient = 0.5;
                float lightIntensity = ambient + diffuse * 0.5;
                vec3 baseColor = length(vColor) > 0.0 ? vColor : vec3(1.0);
                
                vec3 finalColor = baseColor * lightIntensity;
                
                gl_FragColor = vec4(finalColor, opacity);
            }
        `;

        const flipVertexShader = `
            uniform float time;
            uniform float flipSpeed;
            uniform float flipPauseDuration;
            uniform float minDiagonal;
            uniform float maxDiagonal;
            varying vec3 vColor;
            varying vec3 vNormal;
            attribute vec3 glyphCenter;
            attribute float glyphIndex;
            attribute float glyphLineIndex;

            mat4 rotationY(float angle) {
                float s = sin(angle);
                float c = cos(angle);
                return mat4(
                    c, 0.0, s, 0.0,
                    0.0, 1.0, 0.0, 0.0,
                    -s, 0.0, c, 0.0,
                    0.0, 0.0, 0.0, 1.0
                );
            }

            float easeInOutCubic(float t) {
                return t < 0.5 ? 4.0 * t * t * t : 1.0 - pow(-2.0 * t + 2.0, 3.0) / 2.0;
            }

            void main() {
                vColor = color;
                
                // Normalize diagonal position to 0-1 range
                float diagonalValue = glyphCenter.x + glyphCenter.y;
                float normalizedDiagonal = (diagonalValue - minDiagonal) / (maxDiagonal - minDiagonal);
                
                // Map to 0.7 of flip duration so all glyphs complete within the window
                float waveDuration = 0.7;
                float phaseOffset = normalizedDiagonal * waveDuration;
                
                // Animation cycle
                float cycleTime = time * flipSpeed;
                float flipDuration = 1.5;
                float totalCycle = flipDuration + flipPauseDuration + flipDuration + flipPauseDuration;
                float t = mod(cycleTime, totalCycle);
                
                float angle = 0.0;
                
                // Phase 1: Flip forward (0 to PI) - bottom-left to top-right
                if (t < flipDuration) {
                    float progress = t - phaseOffset;
                    if (progress >= 0.0 && progress <= flipDuration) {
                        float normalizedT = clamp(progress / (flipDuration - waveDuration), 0.0, 1.0);
                        angle = easeInOutCubic(normalizedT) * 3.14159;
                    } else if (progress > flipDuration) {
                        angle = 3.14159;
                    }
                }
                // Phase 2: Pause at PI  
                else if (t < flipDuration + flipPauseDuration) {
                    angle = 3.14159;
                }
                // Phase 3: Flip back (PI to 0) - REVERSED: top-right to bottom-left
                else if (t < flipDuration * 2.0 + flipPauseDuration) {
                    float backStart = flipDuration + flipPauseDuration;
                    // Reverse: use (1.0 - normalizedDiagonal) for opposite direction
                    float reversePhase = (1.0 - normalizedDiagonal) * waveDuration;
                    float progress = (t - backStart) - reversePhase;
                    if (progress >= 0.0 && progress <= flipDuration) {
                        float normalizedT = clamp(progress / (flipDuration - waveDuration), 0.0, 1.0);
                        angle = (1.0 - easeInOutCubic(normalizedT)) * 3.14159;
                    } else if (progress < 0.0) {
                        angle = 3.14159;
                    }
                }
                // Phase 4: Pause at 0
                // else: angle stays 0
                
                // Rotate around glyph's own center - stays in place!
                vec3 localPos = position - glyphCenter;
                vec3 rotatedPos = (rotationY(angle) * vec4(localPos, 1.0)).xyz;
                vec3 finalPos = rotatedPos + glyphCenter;
                
                // Transform normal
                vec3 newNormal = (rotationY(angle) * vec4(normal, 0.0)).xyz;
                vNormal = normalize(normalMatrix * newNormal);
                
                vec4 mvPosition = modelViewMatrix * vec4(finalPos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const explodeVertexShader = `
            uniform float time;
            uniform float explodeSpeed;
            uniform float explodeDistance;
            uniform vec3 paragraphCenter;
            varying vec3 vColor;
            varying vec3 vNormal;
            attribute vec3 glyphCenter;
            attribute float glyphIndex;

            // Pseudo-random based on position
            float hash(vec3 p) {
                return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
            }
            
            vec3 hash3(vec3 p) {
                return vec3(
                    hash(p),
                    hash(p + vec3(1.0)),
                    hash(p + vec3(2.0))
                );
            }

            float easeOutElastic(float t) {
                float c4 = (2.0 * 3.14159) / 3.0;
                return t == 0.0 ? 0.0 : t == 1.0 ? 1.0 : 
                       pow(2.0, -10.0 * t) * sin((t * 10.0 - 0.75) * c4) + 1.0;
            }
            
            mat4 rotationMatrix(vec3 axis, float angle) {
                axis = normalize(axis);
                float s = sin(angle);
                float c = cos(angle);
                float oc = 1.0 - c;
                
                return mat4(
                    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                    0.0,                                0.0,                                0.0,                                1.0
                );
            }

            void main() {
                vColor = color;
                
                // Distance from explosion center - determines shockwave timing
                float distFromCenter = length(glyphCenter - paragraphCenter);
                
                // Chaos seeds per glyph and vertex
                vec3 glyphSeed = glyphCenter * 0.01;
                vec3 vertexSeed = position * 0.01;
                vec3 chaos = hash3(glyphSeed) - 0.5;
                
                // Base direction: radial from center
                vec3 radialDir = normalize(glyphCenter - paragraphCenter);
                
                // Add HUGE chaotic deviation - letters scatter in wild directions
                vec3 chaoticDir = normalize(radialDir + chaos * 2.5);
                
                // Animation cycle
                float cycleTime = time * explodeSpeed;
                float cycleDuration = 8.0;  // Extended for longer rest
                float t = mod(cycleTime, cycleDuration);
                
                // Shockwave delay based on distance from center
                float shockwaveDelay = distFromCenter * 0.0008;
                float phaseT = t - shockwaveDelay;
                
                float offset = 0.0;
                float tumbleAngle = 0.0;
                float scatter = 0.0;
                
                // Outward: violent start, coast, slow stop (0.0 - 2.4s)
                if (phaseT < 2.4 && phaseT >= 0.0) {
                    float outT = phaseT / 2.4;
                    
                    // Smooth continuous curve: fast start, ease out to stop
                    float curve = outT * outT * (3.0 - 2.0 * outT);
                    offset = explodeDistance * 4.8 * curve;
                    tumbleAngle = 40.0 * (hash(glyphSeed) - 0.5) * curve;
                    scatter = 200.0 * curve;
                }
                // Hang time at max distance (2.4 - 3.2s) - dramatic pause
                else if (phaseT >= 2.4 && phaseT < 3.2) {
                    offset = explodeDistance * 4.8;
                    tumbleAngle = 40.0 * (hash(glyphSeed) - 0.5);
                    scatter = 200.0;
                }
                // Return: slow start, accelerate back (3.2 - 5.8s)
                else if (phaseT >= 3.2 && phaseT < 5.8) {
                    float returnT = (phaseT - 3.2) / 2.6;
                    
                    // Smooth reverse curve - ensure it reaches 0
                    float curve = returnT * returnT * (3.0 - 2.0 * returnT);
                    offset = explodeDistance * 4.8 * (1.0 - curve);
                    tumbleAngle = 40.0 * (hash(glyphSeed) - 0.5) * (1.0 - curve);
                    scatter = 200.0 * (1.0 - curve);
                }
                // Rest with fully reformed paragraph (5.4 - 8.0s) - 2.6 seconds to appreciate
                // else: all = 0
                
                // Apply chaos to position
                vec3 pos = position;
                
                // Tumble the glyph
                vec3 tumbleAxis = normalize(chaos);
                mat4 rotation = rotationMatrix(tumbleAxis, tumbleAngle);
                vec3 localPos = pos - glyphCenter;
                pos = (rotation * vec4(localPos, 1.0)).xyz + glyphCenter;
                
                // Scatter individual vertices
                vec3 vertexChaos = (hash3(vertexSeed) - 0.5) * scatter;
                pos += vertexChaos;
                
                // Explode outward
                pos += chaoticDir * offset;
                
                // Deform normals with tumble
                vec3 rotatedNormal = (rotation * vec4(normal, 0.0)).xyz;
                vNormal = normalize(normalMatrix * rotatedNormal);
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const orbitVertexShader = `
            uniform float time;
            uniform float orbitRadius;
            uniform float orbitSpeed;
            varying vec3 vColor;
            varying vec3 vNormal;
            attribute vec3 glyphCenter;
            attribute float glyphIndex;

            void main() {
                vColor = color;
                vNormal = normalize(normalMatrix * normal);
                
                // Each glyph orbits with phase offset
                float phase = glyphIndex * 0.3;
                float angle = time * orbitSpeed + phase;
                
                // 3D orbital path - circle in XY, strong Z motion
                vec2 circularOffset = vec2(cos(angle), sin(angle)) * orbitRadius;
                // Z moves independently - bigger amplitude for dramatic forward/back
                float zOffset = sin(angle * 1.5) * orbitRadius * 1.5;
                
                // Apply 3D offset
                vec3 pos = position + vec3(circularOffset.x, circularOffset.y, zOffset);
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const twisterVertexShader = `
            uniform float time;
            uniform float twisterSpeed;
            uniform float twisterHeight;
            uniform float twisterRadius;
            varying vec3 vColor;
            varying vec3 vNormal;
            attribute vec3 glyphCenter;
            attribute float glyphIndex;
            attribute float glyphLineIndex;

            float hash(vec3 p) {
                return fract(sin(dot(p, vec3(12.9898, 78.233, 45.164))) * 43758.5453);
            }

            mat4 rotationMatrix(vec3 axis, float angle) {
                axis = normalize(axis);
                float s = sin(angle);
                float c = cos(angle);
                float oc = 1.0 - c;
                
                return mat4(
                    oc * axis.x * axis.x + c,           oc * axis.x * axis.y - axis.z * s,  oc * axis.z * axis.x + axis.y * s,  0.0,
                    oc * axis.x * axis.y + axis.z * s,  oc * axis.y * axis.y + c,           oc * axis.y * axis.z - axis.x * s,  0.0,
                    oc * axis.z * axis.x - axis.y * s,  oc * axis.y * axis.z + axis.x * s,  oc * axis.z * axis.z + c,           0.0,
                    0.0,                                0.0,                                0.0,                                1.0
                );
            }

            void main() {
                vColor = color;
                
                vec3 glyphSeed = glyphCenter * 0.01;
                float distanceFromCenter = length(glyphCenter.xz);
                float verticalPos = glyphCenter.y;
                
                float vortexPull = exp(-distanceFromCenter * 0.001);
                
                float glyphPhaseOffset = hash(glyphSeed) * 0.5;
                
                float t = time * twisterSpeed;
                
                float vortexAngle = t + verticalPos * 0.004 + vortexPull * 6.0 + glyphPhaseOffset;
                
                float breathe = sin(t * 0.3 + glyphPhaseOffset) * 0.2 + 1.0;
                float spiralRadius = twisterRadius * vortexPull * breathe;
                
                vec2 spiralOffset = vec2(
                    cos(vortexAngle) * spiralRadius,
                    sin(vortexAngle) * spiralRadius
                );
                
                float uplift = sin(vortexAngle + glyphPhaseOffset) * twisterHeight * vortexPull;
                
                vec3 pos = position;
                
                vec3 windAxis = normalize(vec3(
                    hash(glyphSeed) - 0.5,
                    0.8,
                    hash(glyphSeed + vec3(1.0)) - 0.5
                ));
                float tumble = vortexAngle * 0.2 * vortexPull;
                
                vec3 localPos = pos - glyphCenter;
                pos = (rotationMatrix(windAxis, tumble) * vec4(localPos, 1.0)).xyz + glyphCenter;
                
                pos += vec3(spiralOffset.x, uplift, spiralOffset.y);
                
                vec3 rotatedNormal = (rotationMatrix(windAxis, tumble) * vec4(normal, 0.0)).xyz;
                vNormal = normalize(normalMatrix * rotatedNormal);
                
                vec4 mvPosition = modelViewMatrix * vec4(pos, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const offVertexShader = `
            varying vec3 vColor;
            varying vec3 vNormal;

            void main() {
                vColor = color;
                vNormal = normalize(normalMatrix * normal);

                vec4 mvPosition = modelViewMatrix * vec4(position, 1.0);
                gl_Position = projectionMatrix * mvPosition;
            }
        `;

        const standardFragmentShader = `
            uniform float opacity;
            varying vec3 vColor;
            varying vec3 vNormal;

            void main() {
                vec3 lightDirection = normalize(vec3(1.0, 1.0, 1.0));
                vec3 normal = normalize(vNormal);

                float diffuse = max(dot(normal, lightDirection), 0.0);
                float ambient = 0.5;
                float lightIntensity = ambient + diffuse * 0.5;
                vec3 baseColor = length(vColor) > 0.0 ? vColor : vec3(1.0);

                vec3 finalColor = baseColor * lightIntensity;

                gl_FragColor = vec4(finalColor, opacity);
            }
        `;

        function initScene() {
          camera = new THREE.PerspectiveCamera(
            45,
            window.innerWidth / window.innerHeight,
            100,
            50000
          );
          camera.position.set(-20, 20, 3000);

          renderer = new THREE.WebGLRenderer({
            antialias: true,
            precision: "highp",
            powerPreference: "high-performance",
          });
          renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
          renderer.setSize(window.innerWidth, window.innerHeight);
          renderer.outputColorSpace = THREE.SRGBColorSpace;

          document.getElementById("container").appendChild(renderer.domElement);

          controls = new OrbitControls(camera, renderer.domElement);
          controls.enableDamping = true;
          controls.dampingFactor = 0.05;
          controls.screenSpacePanning = false;
          controls.minDistance = 1000;
          controls.maxDistance = 8000;
          controls.maxPolarAngle = Math.PI / 1.2;
          controls.target.set(0, 0, 0);

          const ambientLight = new THREE.AmbientLight(0xffffff, 0.6);
          scene.add(ambientLight);

          const directionalLight = new THREE.DirectionalLight(0xffffff, 0.8);
          directionalLight.position.set(1, 1, 1);
          scene.add(directionalLight);
          window.addEventListener("resize", onWindowResize, false);

          animate();
        }

        function initGUI() {
          gui = new GUI();
          gui.title("Text settings");

          addFontUploadGUI();

          let renderTimeout;
          const debouncedRender = () => {
            clearTimeout(renderTimeout);
            updateStatus("Parameter changed, re-rendering...", "loading");
            renderTimeout = setTimeout(renderText, 50);
          };

          textFolder = gui.addFolder("Text");
          textFolder
            .add(params, "text")
            .name("Content")
            .onChange(debouncedRender);
          textFolder
            .add(params, "fontSize", 30, 150, 5)
            .name("Font size")
            .onChange(debouncedRender);
          textFolder
            .add(params, "letterSpacing", -0.1, 0.2, 0.01)
            .name("Letter spacing")
            .onChange(debouncedRender);
          textFolder
            .add(params, "direction", ["ltr", "rtl"])
            .name("Direction")
            .onChange(debouncedRender);
          textFolder
            .add(params, "depth", 0, 50, 1)
            .name("Depth")
            .onChange(debouncedRender);

          const animationFolder = gui.addFolder("Animation");
          animationFolder
            .add(params, "shaderMode", ["off", "wave", "flip", "explode", "orbit", "twister"])
            .name("Animation mode")
            .onChange((mode) => {
              currentShaderMode = mode;
              switchShaderMode(mode);
            });

          shaderFolders.wave = animationFolder.addFolder("Wave controls");
          shaderFolders.wave
            .add(params, "waveHeight", 0, 50, 1)
            .name("Wave height");
          shaderFolders.wave
            .add(params, "waveFrequency", 0.001, 0.1, 0.001)
            .name("Wave frequency");

          shaderFolders.flip = animationFolder.addFolder("Flip controls");
          shaderFolders.flip
            .add(params, "flipSpeed", 0.1, 3.0, 0.1)
            .name("Flip speed");
          shaderFolders.flip
            .add(params, "flipPauseDuration", 0, 2.0, 0.1)
            .name("Pause duration");

          shaderFolders.explode = animationFolder.addFolder("Explode controls");
          shaderFolders.explode
            .add(params, "explodeSpeed", 0.1, 3.0, 0.1)
            .name("Explode speed");
          shaderFolders.explode
            .add(params, "explodeDistance", 100, 2000, 50)
            .name("Explode distance");

          shaderFolders.orbit = animationFolder.addFolder("Orbit controls");
          shaderFolders.orbit
            .add(params, "orbitRadius", 5, 100, 5)
            .name("Orbit radius");
          shaderFolders.orbit
            .add(params, "orbitSpeed", 0.1, 5.0, 0.1)
            .name("Orbit speed");

          shaderFolders.twister = animationFolder.addFolder("Twister controls");
          shaderFolders.twister
            .add(params, "twisterSpeed", 0.1, 3.0, 0.1)
            .name("Twister speed");
          shaderFolders.twister
            .add(params, "twisterHeight", 0, 300, 10)
            .name("Twister height");
          shaderFolders.twister
            .add(params, "twisterRadius", 50, 500, 10)
            .name("Twister radius");

          updateShaderFolderVisibility('wave');

          const lineBreakingFolder = gui.addFolder("Line breaking");
          lineBreakingFolder
            .add(params, "lineWidth", 500, 3000, 10)
            .name("Line width")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "lineHeight", 0.8, 2.0, 0.05)
            .name("Line height")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "alignment", ["left", "center", "right", "justify"])
            .name("Alignment")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "respectExistingBreaks")
            .name("Respect existing breaks")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "disableSingleWordDetection")
            .name("Disable single-word detection")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "tolerance", 10, 10000, 100)
            .name("Tolerance")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "pretolerance", 10, 1000, 50)
            .name("Pretolerance")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "emergencyStretch", 0, 1000, 50)
            .name("Emergency stretch")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "looseness", -3, 3, 1)
            .name("Looseness")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "linepenalty", 0, 100, 1)
            .name("Line penalty")
            .onChange(debouncedRender);
          lineBreakingFolder
            .add(params, "adjdemerits", 0, 20000, 500)
            .name("Adjacent demerits")
            .onChange(debouncedRender);

          const hyphenationFolder = gui.addFolder("Hyphenation");
          hyphenationFolder
            .add(params, "hyphenate")
            .name("Enable hyphenation")
            .onChange(debouncedRender);
          hyphenationFolder
            .add(params, "language", availableLanguages)
            .name("Language")
            .onChange(debouncedRender);
          hyphenationFolder
            .add(params, "lefthyphenmin", 1, 5, 1)
            .name("Left hyphen min")
            .onChange(debouncedRender);
          hyphenationFolder
            .add(params, "righthyphenmin", 1, 5, 1)
            .name("Right hyphen min")
            .onChange(debouncedRender);
          hyphenationFolder
            .add(params, "hyphenpenalty", 0, 500, 10)
            .name("Hyphen penalty")
            .onChange(debouncedRender);
          hyphenationFolder
            .add(params, "exhyphenpenalty", 0, 500, 10)
            .name("Explicit hyphen penalty")
            .onChange(debouncedRender);
          hyphenationFolder
            .add(params, "doublehyphendemerits", 0, 20000, 500)
            .name("Double hyphen demerits")
            .onChange(debouncedRender);

          const flatteningFolder = gui.addFolder("Curve fidelity");
          flatteningFolder
            .add(params, "distanceTolerance", 0.1, 10.0, 0.1)
            .name("Distance tolerance")
            .onChange(debouncedRender);
          flatteningFolder
            .add(params, "angleTolerance", 0.1, 10.0, 0.05)
            .name("Angle tolerance")
            .onChange(debouncedRender);

          const optimizationFolder = gui.addFolder("Geometry optimization");
          optimizationFolder
            .add(params, "optimizationEnabled")
            .name("Enable V-W optimization")
            .onChange(debouncedRender);
          optimizationFolder
            .add(params, "areaThreshold", 0.1, 15.0, 0.1)
            .name("V-W area threshold (font unitsÂ²)")
            .onChange(debouncedRender);
          optimizationFolder
            .add(params, "colinearThreshold", 0.001, 0.02, 0.0001)
            .name("Colinear threshold (rad)")
            .onChange(debouncedRender);
          optimizationFolder
            .add(params, "minSegmentLength", 0.1, 2.0, 0.05)
            .name("Min segment length")
            .onChange(debouncedRender);
          optimizationFolder
            .add(params, "removeOverlaps", { "Auto (VF=on, Static=off)": null, "Force On": true, "Force Off": false })
            .name("Overlap removal")
            .onChange(debouncedRender);
        }

        function updateShaderFolderVisibility(mode) {
          Object.keys(shaderFolders).forEach(key => {
            if (shaderFolders[key]) {
              // Show folder if it matches mode (hide for 'off' mode)
              if (key === mode) {
                shaderFolders[key].show();
              } else {
                shaderFolders[key].hide();
              }
            }
          });
        }

        function switchShaderMode(mode) {
          if (!textMesh) return;

          updateShaderFolderVisibility(mode);

          const needsAttributes = ['flip', 'explode', 'orbit', 'twister'].includes(mode);
          const hasAttributes = textMesh.geometry.attributes.glyphCenter !== undefined;

          // If switching to a mode that needs attributes but geometry doesn't have them, re-render
          if (needsAttributes && !hasAttributes) {
            renderText();
            return;
          }

          // If switching from attribute mode to non-attribute mode, re-render for efficiency
          if (!needsAttributes && hasAttributes) {
            renderText();
            return;
          }

          // Calculate diagonal range from geometry attributes (if they exist)
          let minDiagonal = 0;
          let maxDiagonal = 1;
          
          if (hasAttributes) {
            const glyphCenterAttr = textMesh.geometry.attributes.glyphCenter;
            minDiagonal = Infinity;
            maxDiagonal = -Infinity;
            
            for (let i = 0; i < glyphCenterAttr.count; i++) {
              const x = glyphCenterAttr.getX(i);
              const y = glyphCenterAttr.getY(i);
              const diagonal = x + y;
              minDiagonal = Math.min(minDiagonal, diagonal);
              maxDiagonal = Math.max(maxDiagonal, diagonal);
            }
          }

          const paragraphCenter = new THREE.Vector3(0, 0, 0);

          // Dispose old material
          if (textMesh.material) {
            textMesh.material.dispose();
          }

          // Create and assign new material
          textMesh.material = createMaterialForMode(mode, paragraphCenter, minDiagonal, maxDiagonal);
        }

        function onWindowResize() {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
        }

        function createMaterialForMode(mode, paragraphCenter, minDiagonal, maxDiagonal) {
          const baseConfig = {
            vertexColors: true,
            side: THREE.DoubleSide,
            transparent: true,
            defines: {
              USE_COLOR: "",
            },
          };

          switch (mode) {
            case 'off':
              return new THREE.ShaderMaterial({
                uniforms: {
                  time: { value: time },
                  opacity: { value: 1.0 },
                },
                vertexShader: offVertexShader,
                fragmentShader: standardFragmentShader,
                ...baseConfig,
              });

            case 'flip':
              return new THREE.ShaderMaterial({
                uniforms: {
                  time: { value: time },
                  flipSpeed: { value: params.flipSpeed },
                  flipPauseDuration: { value: params.flipPauseDuration },
                  minDiagonal: { value: minDiagonal },
                  maxDiagonal: { value: maxDiagonal },
                  opacity: { value: 1.0 },
                },
                vertexShader: flipVertexShader,
                fragmentShader: standardFragmentShader,
                ...baseConfig,
              });

            case 'explode':
              return new THREE.ShaderMaterial({
                uniforms: {
                  time: { value: time },
                  explodeSpeed: { value: params.explodeSpeed },
                  explodeDistance: { value: params.explodeDistance },
                  paragraphCenter: { value: paragraphCenter },
                  opacity: { value: 1.0 },
                },
                vertexShader: explodeVertexShader,
                fragmentShader: standardFragmentShader,
                ...baseConfig,
              });

            case 'orbit':
              return new THREE.ShaderMaterial({
                uniforms: {
                  time: { value: time },
                  orbitRadius: { value: params.orbitRadius },
                  orbitSpeed: { value: params.orbitSpeed },
                  opacity: { value: 1.0 },
                },
                vertexShader: orbitVertexShader,
                fragmentShader: standardFragmentShader,
                ...baseConfig,
              });

            case 'twister':
              return new THREE.ShaderMaterial({
                uniforms: {
                  time: { value: time },
                  twisterSpeed: { value: params.twisterSpeed },
                  twisterHeight: { value: params.twisterHeight },
                  twisterRadius: { value: params.twisterRadius },
                  opacity: { value: 1.0 },
                },
                vertexShader: twisterVertexShader,
                fragmentShader: standardFragmentShader,
                ...baseConfig,
              });

            case 'wave':
            default:
              return new THREE.ShaderMaterial({
                uniforms: {
                  time: { value: time },
                  waveHeight: { value: params.waveHeight },
                  waveFrequency: { value: params.waveFrequency },
                  opacity: { value: 1.0 },
                },
                vertexShader: waveVertexShader,
                fragmentShader: waveFragmentShader,
                ...baseConfig,
              });
          }
        }

        function animate() {
          requestAnimationFrame(animate);
          time += 0.01;
          
          if (textMesh?.material instanceof THREE.ShaderMaterial) {
            textMesh.material.uniforms.time.value = time;
            
            // Update mode-specific uniforms
            const uniforms = textMesh.material.uniforms;
            switch (currentShaderMode) {
              case 'wave':
                if (uniforms.waveHeight) uniforms.waveHeight.value = params.waveHeight;
                if (uniforms.waveFrequency) uniforms.waveFrequency.value = params.waveFrequency;
                break;
              case 'flip':
                if (uniforms.flipSpeed) uniforms.flipSpeed.value = params.flipSpeed;
                if (uniforms.flipPauseDuration) uniforms.flipPauseDuration.value = params.flipPauseDuration;
                break;
              case 'explode':
                if (uniforms.explodeSpeed) uniforms.explodeSpeed.value = params.explodeSpeed;
                if (uniforms.explodeDistance) uniforms.explodeDistance.value = params.explodeDistance;
                break;
            case 'orbit':
              if (uniforms.orbitRadius) uniforms.orbitRadius.value = params.orbitRadius;
              if (uniforms.orbitSpeed) uniforms.orbitSpeed.value = params.orbitSpeed;
              break;
            case 'twister':
              if (uniforms.twisterSpeed) uniforms.twisterSpeed.value = params.twisterSpeed;
              if (uniforms.twisterHeight) uniforms.twisterHeight.value = params.twisterHeight;
              if (uniforms.twisterRadius) uniforms.twisterRadius.value = params.twisterRadius;
              break;
          }
        }
        
        controls.update();
        renderer.render(scene, camera);
      }

        async function renderText() {
          if (isRendering) return;
          isRendering = true;

          try {
            updateStatus("Rendering text...", "loading");

            const fontVariations = {};
            for (const key in params) {
              if (key.startsWith('fontVar_')) {
                const tag = key.replace('fontVar_', '');
                fontVariations[tag] = params[key];
              }
            }

            let font;
            if (customFontBuffer) {
              font = customFontBuffer;
            } else {
              font = "./fonts/NimbusSanL-Reg.woff";
            }

            const needsGlyphAttributes = ['flip', 'explode', 'orbit', 'twister'].includes(params.shaderMode);

            const startTime = performance.now();
            const result = await Text.create({
              text: params.text,
              font: font,
              size: params.fontSize,
              depth: params.depth,
              lineHeight: params.lineHeight,
              letterSpacing: params.letterSpacing,
              fontVariations: Object.keys(fontVariations).length > 0 ? fontVariations : undefined,
              removeOverlaps: params.removeOverlaps,
              separateGlyphsWithAttributes: needsGlyphAttributes,
              curveFidelity: {
                distanceTolerance: params.distanceTolerance,
                angleTolerance: params.angleTolerance,
              },
              geometryOptimization: {
                enabled: params.optimizationEnabled,
                areaThreshold: params.areaThreshold,
                colinearThreshold: params.colinearThreshold,
                minSegmentLength: params.minSegmentLength,
              },
              layout: {
                width: params.lineWidth,
                align: params.alignment,
                direction: params.direction,
                hyphenate: params.hyphenate,
                language: params.language,
                tolerance: params.tolerance,
                pretolerance: params.pretolerance,
                emergencyStretch: params.emergencyStretch,
                respectExistingBreaks: params.respectExistingBreaks,
                disableSingleWordDetection: params.disableSingleWordDetection,
                lefthyphenmin: params.lefthyphenmin,
                righthyphenmin: params.righthyphenmin,
                looseness: params.looseness,
                linepenalty: params.linepenalty,
                adjdemerits: params.adjdemerits,
                hyphenpenalty: params.hyphenpenalty,
                exhyphenpenalty: params.exhyphenpenalty,
                doublehyphendemerits: params.doublehyphendemerits,
                singleworddemerits: params.singleworddemerits,
              },
            });

            const loadedFont = result.getLoadedFont();
            const axes = loadedFont?.variationAxes || null;
            if (customFontBuffer && axes) {
              addVariableFontControls(axes, textFolder);
            }

            if (textMesh) {
              scene.remove(textMesh);
              if (textMesh.geometry) textMesh.geometry.dispose();
              if (textMesh.material) textMesh.material.dispose();
            }

            // Center the geometry
            result.geometry.computeBoundingBox();
            const center = new THREE.Vector3();
            result.geometry.boundingBox.getCenter(center);
            result.geometry.translate(-center.x, -center.y, -center.z);

            // Update glyphCenter attributes to match the translation
            if (needsGlyphAttributes && result.geometry.attributes.glyphCenter) {
              const glyphCenterAttr = result.geometry.attributes.glyphCenter;
              for (let i = 0; i < glyphCenterAttr.count; i++) {
                glyphCenterAttr.setX(i, glyphCenterAttr.getX(i) - center.x);
                glyphCenterAttr.setY(i, glyphCenterAttr.getY(i) - center.y);
                glyphCenterAttr.setZ(i, glyphCenterAttr.getZ(i) - center.z);
              }
              glyphCenterAttr.needsUpdate = true;
            }

            // Calculate diagonal range for flip shader (after centering)
            let minDiagonal = Infinity;
            let maxDiagonal = -Infinity;

            if (needsGlyphAttributes && result.geometry.attributes.glyphCenter) {
              const glyphCenterAttr = result.geometry.attributes.glyphCenter;
              for (let i = 0; i < glyphCenterAttr.count; i++) {
                const x = glyphCenterAttr.getX(i);
                const y = glyphCenterAttr.getY(i);
                const diagonal = x + y;
                minDiagonal = Math.min(minDiagonal, diagonal);
                maxDiagonal = Math.max(maxDiagonal, diagonal);
              }
            }

            const paragraphCenter = new THREE.Vector3(0, 0, 0);
            const material = createMaterialForMode(params.shaderMode, paragraphCenter, minDiagonal, maxDiagonal);

            textMesh = new THREE.Mesh(result.geometry, material);
            textMesh.rotation.x = 0;
            textMesh.rotation.y = 0.5;

            scene.add(textMesh);
            
            const renderTime = Math.round(performance.now() - startTime);
            updateStatus(`${result.stats.trianglesGenerated.toLocaleString()} triangles in ${renderTime}ms`, "ready");
          } catch (error) {
            console.error("Error rendering text:", error);
            updateStatus(`Error: ${error.message}`, "error");
          } finally {
            isRendering = false;
          }
        }

        function addFontUploadGUI() {
          const fontFolder = gui.addFolder("Font");

          // Current font display
          window.fontDisplay = { currentFont: currentFontName };
          window.fontController = fontFolder.add(window.fontDisplay, "currentFont").name("Current").disable();

          // Upload button
          const uploadAction = {
            uploadFont: function () {
              const input = document.createElement("input");
              input.type = "file";
              input.accept = ".ttf,.otf,.woff";
              input.onchange = handleFontUpload;
              input.click();
            },
          };
          fontFolder.add(uploadAction, "uploadFont").name("Add custom font");

          // Privacy disclaimer
          const privacyDisplay = { privacy: "Files stay local" };
          fontFolder.add(privacyDisplay, "privacy").name("Privacy").disable();

          // Create drag overlay
          createDragOverlay();
        }

        function createDragOverlay() {
          const overlay = document.createElement("div");
          overlay.id = "font-drag-overlay";
          overlay.innerHTML = `
            <div class="drag-border"></div>
            <div class="drag-content">
              <h2>Drop Font File Here</h2>
              <p>TTF, OTF, or WOFF supported. No files uploaded, all are local in your browser</p>
              <p class="current">Current: <span>${currentFontName}</span></p>
            </div>
          `;

          const style = document.createElement("style");
          style.textContent = `
            #font-drag-overlay {
              position: fixed;
              top: 0;
              left: 0;
              width: 100%;
              height: 100%;
              background: rgba(0, 0, 0, 0.9);
              display: none;
              align-items: center;
              justify-content: center;
              z-index: 10000;
              backdrop-filter: blur(5px);
            }
            
            .drag-border {
              position: absolute;
              top: 24px;
              left: 24px;
              right: 24px;
              bottom: 24px;
              border: 4px dashed #0066cc;
              border-radius: 8px;
              pointer-events: none;
            }
            
            .drag-content {
              text-align: center;
              color: white;
              padding: 40px;
              position: relative;
              z-index: 1;
            }
            
            .drag-content h2 {
              margin: 0 0 16px 0;
              font-size: 48px;
              color: #0066cc;
              font-weight: 600;
            }
            
            .drag-content p {
              margin: 0 0 8px 0;
              font-size: 24px;
              color: #ccc;
            }
            
            .drag-content p:last-child {
              margin: 0;
              font-size: 18px;
              color: #888;
            }
            
            .drag-content .current span {
              color: #0066cc;
              font-weight: 500;
            }
          `;

          document.head.appendChild(style);
          document.body.appendChild(overlay);

          // Drag and drop events (only on non-mobile)
          const isMobile = window.innerWidth < 768 || "ontouchstart" in window;
          if (isMobile) return;

          document.addEventListener("dragover", (e) => {
            e.preventDefault();
            const items = Array.from(e.dataTransfer.items);
            const hasFont = items.some((item) => {
              const type = item.type;
              return type === "font/ttf" || type === "font/otf";
            });

            if (hasFont) {
              const currentSpan = overlay.querySelector(".current span");
              if (currentSpan) {
                currentSpan.textContent = currentFontName;
              }
              overlay.style.display = "flex";
            }
          });

          document.addEventListener("dragleave", (e) => {
            if (!document.body.contains(e.relatedTarget)) {
              overlay.style.display = "none";
            }
          });

          document.addEventListener("drop", (e) => {
            e.preventDefault();
            overlay.style.display = "none";

            const files = Array.from(e.dataTransfer.files);
            const fontFile = files.find((file) => {
              const ext = file.name.toLowerCase();
              return ext.endsWith(".ttf") || ext.endsWith(".otf") || ext.endsWith(".woff");
            });

            if (fontFile) {
              loadCustomFont(fontFile);
            }
          });
        }

        function handleFontUpload(event) {
          const file = event.target.files[0];
          if (file) {
            loadCustomFont(file);
          }
        }

        function clearVariableFontControls() {
          variableFontControllers.forEach(controller => {
            controller.destroy();
          });
          variableFontControllers = [];
        }

        function addVariableFontControls(axes, textFolder) {
          clearVariableFontControls();
          
          if (!axes || Object.keys(axes).length === 0) {
            return;
          }

          for (const [tag, axisInfo] of Object.entries(axes)) {
            const name = axisInfo.name || tag;

            params[`fontVar_${tag}`] = axisInfo.default;
            
            const controller = textFolder
              .add(params, `fontVar_${tag}`, axisInfo.min, axisInfo.max, tag === "slnt" ? 0.1 : 1)
              .name(name)
              .onChange(() => {
                renderText();
              });
              
            variableFontControllers.push(controller);
          }
        }

        async function loadCustomFont(file) {
          try {
            updateStatus(`Loading ${file.name}...`, "loading");

            customFontBuffer = await file.arrayBuffer();
            currentFontName = file.name;

            if (window.fontDisplay && window.fontController) {
              window.fontDisplay.currentFont = currentFontName;
              window.fontController.updateDisplay();
            }

            await renderText();
          } catch (error) {
            console.error("Font loading error:", error);
            updateStatus(`Error loading ${file.name}: ${error.message}`, "error");
          }
        }

        async function init() {
          updateStatus("Initializing Three.js...", "loading");
          initScene();
          initGUI();
          
          await renderText();
        }

        init().catch((error) => {
          console.error("Initialization error:", error);
          updateStatus("Initialization failed", "error");
        });
      })();
    </script>
  </body>
</html>

